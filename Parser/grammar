non_terminal {
    program
    stmts
    stmt
    defs
    def
    variable types ident_type
    if_stmt if_else_stmt while_stmt for_stmt expr func_def break_stmt continue_stmt return_stmt
    arith_expr rel_expr logical_expr assign_expr call_expr primary_expr
    binary_arith_expr unary_expr 
    unary_expr_before unary_expr_after
    arith_op rel_op logical_binary_op unary_op_af unary_op_bf assign_op
    binary_logical_expr not_expr
    BOOLEAN ARRAY_CONST OBJECT_CONST
    ident_list expr_list element_list pair_element_list pair_element
    math_call string_method_call array_method_call object_method_call object_function_call function_call print_call
    math_abs math_pow math_sqrt math_round math_floor math_ceil math_sin math_cos
    array_method object_method string_method
    string_concat string_upperCase string_lowCase string_substring string_size string_slice
    array_get array_push array_pop array_set array_size array_join array_to_string
    object_get object_insert object_delete object_set object_size
}

terminal {
    PLUS SUB MULT EXP DIV MODULO UMINUS UPLUS PLUS_PLUS SUB_SUB
    GREATER LESS EQUAL_TO EQUAL_VALUE_TYPE NOT_EQUAL_TO NOT_EQUAL_VALUE_TYPE GREATER_EQUAL LESS_EQUAL
    AND OR NOT
    ASSIGN PLUS_ASSIGN SUB_ASSIGN MULT_ASSIGN DIV_ASSIGN MOD_ASSIGN EXP_ASSIGN LEFT_SHIFT_ASSIGN RIGHT_SHIFT_ASSIGN UN_RIGHT_SHIFT_ASSIGN
    true false
    ";"
    if else while for break continue return
    function "(" ")"
    "[" "]"
    ":" "{" "}"
    "Math" "console.log"
    abs pow sqrt round floor ceil sin cos 
    push pop set join tostring
    delete length
    concat toUpperCase toLowerCase substring slice 
    var let const " "
    "." "," "()"
}

define program {
    defs
}

define defs {
    list_of def
}

define stmts {
    list_of stmt
}

define stmt {
    any_of {
        if_stmt                 : "Do something if a condition is true"
        if_else_stmt            : "Do something if a condition is true, else do something else"
        while_stmt              : "Do something while a condition is true"
        for_stmt                : "Do something while a condition is true. Commonly used with a known number of iterations."
        expr(expr_stmt)         : "A single expression as a statement"
        break_stmt              : "Exit from the current loop"
        continue_stmt           : "Continue to the next iteration of the current loop"
        return_stmt             : "Return an expression as the result of the current function"
    }
}

define def {
    any_of {
        stmt
        func_def           : "Define reusable code as a function"
    }
}

define expr {
    any_of {
        arith_expr              : "Perform a mathematic operation"
        rel_expr                : "An operator that compares the two operands and returns true or false"
        logical_expr            : "An expression that evaluates to true or false"
        assign_expr             : "Set a variable's value"
        call_expr               : "Call a user-defined or built-in function/method"
        primary_expr            : "An identifier or a constant"
    }
}

define arith_expr {
    any_of {
        binary_arith_expr       : "An arithmetic expression with two operands"
        unary_expr              : "Unary expression operator with single operand,either before or after the operator"
    }
}

define binary_arith_expr {
    expr                    : "The first operand"
    arith_op                : "An arithmetic operator(e.g. +, -)"
    expr                    : "The second operand"
}

define unary_expr{
    any_of {
        unary_expr_before   :"The unary operator before the operand"
        unary_expr_after    :"The unary operator after the operand"
    }
}

define unary_expr_after {
    expr                : "The single operand"
    unary_op_af         : "Unary operator with one operand"
}

define unary_expr_before {
    unary_op_bf         : "Unary operator with one operand"
    expr                : "The single operand"
}

define unary_op_af {
    any_of {
        PLUS_PLUS("++")      : "Post-increament of the operand value by one"
        SUB_SUB("--")        : "Post-decreament of the operand value by one"
    }
}

define unary_op_bf {
    any_of {
        UMINUS("-")          : "Negates the value of its operand"
        UPLUS("+")           : "Attempts to convert the operand to a number, if it is not already"
        PLUS_PLUS("++")      : "Pre-increament of the operand value by one"
        SUB_SUB("--")        : "Pre-decreament of the operand value by one"
    }
}

define arith_op {
    any_of {
        PLUS("+")                   : "Performs addition"
        SUB("-")                    : "Performs subtraction"
        MULT("*")                   : "Performs multipliction"
        EXP("**")                   : "Performs Exponentation"
        DIV("/")                    : "Performs division"
        MODULO("%")                 : "Performs the modulo operation"
    }
}

define rel_expr {
    expr                    : "The first operand"
    rel_op                  : "A comparison operator that returns true or false (e.g <, >)"
    expr                    : "The second operand"
}

define rel_op {
    any_of {
        GREATER(">")                : "Returns true if the first operand is greater than the second operand, else returns false"
        LESS("<")                   : "Returns true if the first operand is less than the second operand, else returns false"
        EQUAL_TO("==")              : "Returns true if the first operand is equal to the second operand, else returns false"
        EQUAL_VALUE_TYPE("===")     : "Returns true if the first operand is equal and has the same type to the second operand, else returns false"   
        NOT_EQUAL_TO("!=")          : "Returns true if the first operand not equal to the second operand, else returns false"
        NOT_EQUAL_VALUE_TYPE("!==") : "Returns true if the first operand not equal or has different type to the second operand, else returns false"
        GREATER_EQUAL(">=")         : "Returns true if the first operand is greater than or equal to the second operand, else returns false"
        LESS_EQUAL("<=")            : "Returns true if the first operand is less than or equal to the second operand, else returns false"    
    }
}

define logical_expr {
    any_of {
        binary_logical_expr     : "Performs a binary operation with two operands"
        not_expr                : "Performs logical negation. True becomes false and false becomes true"
    }
}

define binary_logical_expr {
    expr                    : "The first operand"
    logical_binary_op       : "Performs a binary operation with two operands"
    expr                    : "The second operand"
}

define logical_binary_op {
    any_of {
        AND("&&")           : "Returns true if both operands are true, else returns false"
        OR("||")            : "Returns true if either operand is true, else returns false"
    }
}

define not_expr {
    NOT("!")                : "Returns true if the operand is false, else returns false"
    expr                    : "The operand"
}

define variable {
    any_of {
        IDENT           :"Without type. If the variable is not declared, it is automatically declared with var"
        ident_type      :"Identifier with type"
    }
}

define ident_type {
    types IDENT         :"Select type of identifier"
}

define types {
    any_of {
        var             :"The scope of a var variable is functional scope"
        let             :"The scope of a let variable is block scope"
        const           :"The scope of a const variable is block scope"
    }
}

define primary_expr {
    any_of {
        variable                : "An identifier starting with _ or a uppercase/lowercase letter following by 0 or more characters that can be _ numbers lowercase/uppercase letters"
        INT_CONST               : "An integer is a positive, zero, or negative number that can be written without a fractional component (i.e. no decimal point places)"
        FLOAT_CONST             : "A floating-point number is a rational number (i.e. includes numbers with decimal point places"
        CHAR_CONST              : "One single character"
        STRING_CONST            : "Any sequence of characters or the empty sequence"
        BOOLEAN                 : "One of true or false"
        ARRAY_CONST             : "An array of elements"
        OBJECT_CONST            : "Variable with many values as pairs (name:value)"
        func_def                : "Function definition as a value of an object"
    }
}

define BOOLEAN {
    any_of {
        true
        false
    }
}

define ARRAY_CONST {
    "[" element_list "]"
}

define element_list {
    list_of expr(element)
}

define OBJECT_CONST {
    "{" pair_element_list "}"
}

define pair_element_list {
    list_of pair_element
}

define pair_element {
    IDENT           : "The identifier of the value"
    ":"             : "The pair"   
    expr(value)     : "The value of the property"
}

define assign_expr {
    IDENT                   :"Left operand to be assigned"
    assign_op               :"Assign operator, simple or with an operation "
    expr                    :"Right operand"
}

define assign_op {
    any_of{
        ASSIGN("=")                     :"Assigns the right operand to the left operand"            
        PLUS_ASSIGN("+=")               :"Sums up left and right operand values and assigns the result to the left operand"
        SUB_ASSIGN("-=")                :"Subtract right operand value from the left operand value and assigns the result to the left operand"
        MULT_ASSIGN("*=")               :"Multiply left and right operand values and assigns the result to the left operand"
        DIV_ASSIGN("/=")                :"Divide left operand value by right operand value and assign the result to the left operand"
        MOD_ASSIGN("%=")                :"Get the modulus of left operand divide by right operand and assign resulted modulus to the left operand"
        EXP_ASSIGN("**=")               :"Raises the value of left operand to the power of the right operand and assign the result to the left operand"
        LEFT_SHIFT_ASSIGN("<<=")        :"Moves the specified amount of bits(right operand) to the left and assigns the result to the left operand"
        RIGHT_SHIFT_ASSIGN(">>=")       :"Moves the specified amount of bits(right operand) to the right and assigns the result to the left operand"
        UN_RIGHT_SHIFT_ASSIGN(">>>=")   :"Unsigned -  moves the specified amount of bits to the right and assigns the result to the left operand"
    }
}

define func_def {
    function IDENT(Name) "(" ident_list ")" "{" stmts "}"
}

define break_stmt {
    break ";"
}

define continue_stmt {
    continue ";"
}

define return_stmt {
    return
    expr
    ";"
}

define call_expr {
    any_of {
        math_call               : "Use a built-in math function"
        string_method_call      : "Use a built-in string method"
        array_method_call       : "Use a built-in array method"
        object_method_call      : "Use a built-in object method"
        object_function_call    : "Use a function which is member of an object as \"object.function()\""
        function_call           : "Use a user-defined function as \"name(params);\""
        print_call              : "Use a built-in function to print the value of the given expression (text, number etc.)"
    } 
}

define math_call {
    any_of {
        math_abs(abs)               : "Returns the absolute value of a number"
        math_pow(pow)               : "pow(x,y) Returns base x to the exponent power y (that is, x^y)"
        math_sqrt(sqrt)             : "Get the square root of a number"
        math_round(round)           : "Get the nearest integer to the given number"
        math_floor(floor)           : "Get the greatest integer less than or equal to the given number"
        math_ceil(ceil)             : "Get the least integer greater than or equal to the given number"
        math_sin(sin)               : "Get the sine of the given angle in degrees"
        math_cos(cos)               : "Get the cosine of the given angle in degrees"
    }
}

define math_abs {
    "Math" "." abs "(" expr(value) ")"
}

define math_pow {
    "Math" "." pow "(" expr(number) "," expr(exponent) ")"
}

define math_sqrt {
    "Math" "." sqrt "(" expr(number) ")"
}

define math_round {
    "Math" "." round "(" expr(number) ")"
}

define math_floor {
    "Math" "." floor "(" expr(number) ")"
}

define math_ceil {
    "Math" "." ceil "(" expr(number) ")"
}

define math_sin {
    "Math" "." sin "(" expr(number) ")"
}

define math_cos {
    "Math" "." cos "(" expr(number) ")"
}

define string_method_call {
    expr("string") "." string_method
}

define string_method {
    any_of {
        string_concat(concat)                           : "Join two strings to one"
        string_upperCase(toUpperCase)                   : "A string is converted to upper case"
        string_lowCase(toLowCase)                       : "A string is converted to lower case"
        string_substring(substring)                     : "Get a substring of a string, giving a start position and an end position"
        string_size(length)                             : "Get the count of characters contained in the string"
        string_slice(slice)                             : "Extracts a part of a string and returns the extracted part in a new string, giving a start position and an end position"
    }
}

define string_concat {
    concat "(" expr("string2") ")"
}

define string_upperCase {
    toUpperCase "()"
}

define string_lowCase {
    toLowerCase "()"
}

define string_substring {
    substring "(" expr(start_index) "," expr(end_index) ")"
}

define string_size {
    length
}

define string_slice {
    slice "(" expr(start_index) "," expr(end_index) ")"
}

define array_method_call {
    IDENT(arrayName) "." array_method
}

define array_method {
    any_of { 
        array_get(get)                  : "Get an element by its position in the array"
        array_push(push)                : "Insert an element at the end of the array"
        array_pop(pop)                  : "Returns the last element of the array"
        array_set(set)                  : "Modify an element in a position of the array to a new character"
        array_size(length)              : "Get the count of elements in the array"
        array_join(join)                : "The join method also joins all array elements into a string, you can specify the separator"
        array_to_string(tostring)       : "Converts an array to a string of (comma separated) array values."
    }
}

define array_get {
    "[" primary_expr(index) "]"
}

define array_push {
    push "(" expr(element) ")"
}

define array_pop {
    pop "()"
}

define array_set {
    set "(" expr(index) "," expr(element) ")"
}

define array_size {
    length
}

define array_join {
    join "(" primary_expr(seperator) ")"
}

define array_to_string {
    tostring
}

define object_method_call {
    IDENT("object name") "." object_method
}

define object_method {
    any_of { 
        object_get(get)                 : "Get an element by its property name in the object e.g objectName.property"
        object_delete(delete)           : "Delete a pair (property:value) by property name"
        object_set(set)                 : "Modify a value by its property name in the object to a new value. If the property does not exist,the pair property:value will be added in the object"
        object_size(length)             : "Get the count of properties in the object"
    }
}

define object_get {
    "[" expr(property) "]"
}

define object_delete {
    delete "[" expr(property) "]"
}

define object_set {
    set "(" expr(value) "," expr(property) ")"
}

define object_size {
    length
}

define object_function_call {
    IDENT("object name") "." IDENT("function name") "(" expr_list ")"
}

define function_call {
    IDENT("function name") "(" expr_list ")"
}

define print_call {
    "console.log" "(" expr_list ")"
}

define if_stmt {
    if "(" expr(condition_expr) ")" "{" stmts(if_part) "}"
}

define if_else_stmt {
    if "(" expr(condition_expr) ")" "{" stmts(if_part) "}" else "{" stmts(else_part) "}"
}

define while_stmt {
    while "(" expr(condition_expr) ")" "{" stmts(while_part) "}"
}

define for_stmt {
    for "("
    expr(initialization_expr) ";"
    expr(condition_expr) ";"
    expr(step_expr) ")"
    "{" stmts(for_part) "}"
}

define ident_list {
    list_of variable
}

define expr_list {
    list_of expr(arg)
}