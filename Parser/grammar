non_terminal {
    program
    stmts
    stmt
    defs
    def
    variable types ident_type
    if_stmt if_else_stmt while_stmt for_stmt expr func_def break_stmt continue_stmt return_stmt
    arith_expr rel_expr logical_expr assign_expr call_expr primary_expr
    binary_arith_expr unary_expr 
    unary_expr_before unary_expr_after
    arith_op rel_op logical_binary_op unary_op_af unary_op_bf assign_op
    binary_logical_expr not_expr
    BOOLEAN ARRAY_CONST OBJECT_CONST
    input_output_call math_call string_method_call array_method_call object_method_call function_call object_function_call
    ident_list expr_list element_list pair_element_list pair_element
    array_method object_method string_method
    array_get array_insert array_push_back array_pop array_set array_size array_join
    object_get object_insert object_delete object_set object_size
    string_append string_get_character string_get_substring string_size
    input_output_print input_output_input
    math_pow math_sqrt math_round math_floor math_ceiling math_sin math_cos
}

terminal {
    PLUS SUB MULT EXP DIV MODULO UMINUS UPLUS PLUS_PLUS SUB_SUB
    GREATER LESS EQUAL_TO EQUAL_VALUE_TYPE NOT_EQUAL_TO NOT_EQUAL_VALUE_TYPE GREATER_EQUAL LESS_EQUAL
    AND OR NOT
    ASSIGN PLUS_ASSIGN SUB_ASSIGN MULT_ASSIGN DIV_ASSIGN MOD_ASSIGN EXP_ASSIGN LEFT_SHIFT_ASSIGN RIGHT_SHIFT_ASSIGN UN_RIGHT_SHIFT_ASSIGN
    true false
    ";"
    if else while for break continue return
    CALL function "(" ")" WITH
    ARRAY "[" "]"
    OBJECT ":" "{" "}"
    get insert push pop set length
    getP deleteP setP sizeP
    "IN STRING"
    append get_character get_substring
    print input
    pow sqrt round floor ceiling sin cos 
    var let const " "
    "."
}

define program {
    defs
}

define defs {
    list_of def
}

define stmts {
    list_of stmt
}

define stmt {
    any_of {
        if_stmt                 : "Do something if a condition is true"
        if_else_stmt            : "Do something if a condition is true, else do something else"
        while_stmt              : "Do something while a condition is true"
        for_stmt                : "Do something while a condition is true. Commonly used with a known number of iterations."
        expr(expr_stmt)         : "A single expression as a statement"
        break_stmt              : "Exit from the current loop"
        continue_stmt           : "Continue to the next iteration of the current loop"
        return_stmt             : "Return an expression as the result of the current function"
    }
}

define def {
    any_of {
        stmt
        func_def           : "Define reusable code as a function"
    }
}

define expr {
    any_of {
        arith_expr              : "Perform a mathematic operation"
        rel_expr                : "An operator that compares the two operands and returns true or false"
        logical_expr            : "An expression that evaluates to true or false"
        assign_expr             : "Set a variable's value"
        call_expr               : "Call a user-defined or built-in function/method"
        primary_expr            : "An identifier or a constant"
    }
}

define arith_expr {
    any_of {
        binary_arith_expr       : "An arithmetic expression with two operands"
        unary_expr              : "Unary expression operator with single operand,either before or after the operator"
    }
}

define binary_arith_expr {
    expr                    : "The first operand"
    arith_op                : "An arithmetic operator(e.g. +, -)"
    expr                    : "The second operand"
}

define unary_expr{
    any_of {
        unary_expr_before   :"The unary operator before the operand"
        unary_expr_after    :"The unary operator after the operand"
    }
}

define unary_expr_after {
    expr                : "The single operand"
    unary_op_af         : "Unary operator with one operand"
}

define unary_expr_before {
    unary_op_bf         : "Unary operator with one operand"
    expr                : "The single operand"
}

define unary_op_af {
    any_of {
        PLUS_PLUS("++")      : "Post-increament of the operand value by one"
        SUB_SUB("--")        : "Post-decreament of the operand value by one"
    }
}

define unary_op_bf {
    any_of {
        UMINUS("-")          : "Negates the value of its operand"
        UPLUS("+")           : "Attempts to convert the operand to a number, if it is not already"
        PLUS_PLUS("++")      : "Pre-increament of the operand value by one"
        SUB_SUB("--")        : "Pre-decreament of the operand value by one"
    }
}

define arith_op {
    any_of {
        PLUS("+")                   : "Performs addition"
        SUB("-")                    : "Performs subtraction"
        MULT("*")                   : "Performs multipliction"
        EXP("**")                   : "Performs Exponentation"
        DIV("/")                    : "Performs division"
        MODULO("%")                 : "Performs the modulo operation"
    }
}

define rel_expr {
    expr                    : "The first operand"
    rel_op                  : "A comparison operator that returns true or false (e.g <, >)"
    expr                    : "The second operand"
}

define rel_op {
    any_of {
        GREATER(">")                : "Returns true if the first operand is greater than the second operand, else returns false"
        LESS("<")                   : "Returns true if the first operand is less than the second operand, else returns false"
        EQUAL_TO("==")              : "Returns true if the first operand is equal to the second operand, else returns false"
        EQUAL_VALUE_TYPE("===")     : "Returns true if the first operand is equal and has the same type to the second operand, else returns false"   
        NOT_EQUAL_TO("!=")          : "Returns true if the first operand not equal to the second operand, else returns false"
        NOT_EQUAL_VALUE_TYPE("!==") : "Returns true if the first operand not equal or has different type to the second operand, else returns false"
        GREATER_EQUAL(">=")         : "Returns true if the first operand is greater than or equal to the second operand, else returns false"
        LESS_EQUAL("<=")            : "Returns true if the first operand is less than or equal to the second operand, else returns false"    
    }
}

define logical_expr {
    any_of {
        binary_logical_expr     : "Performs a binary operation with two operands"
        not_expr                : "Performs logical negation. True becomes false and false becomes true"
    }
}

define binary_logical_expr {
    expr                    : "The first operand"
    logical_binary_op       : "Performs a binary operation with two operands"
    expr                    : "The second operand"
}

define logical_binary_op {
    any_of {
        AND("&&")           : "Returns true if both operands are true, else returns false"
        OR("||")            : "Returns true if either operand is true, else returns false"
    }
}

define not_expr {
    NOT("!")                : "Returns true if the operand is false, else returns false"
    expr                    : "The operand"
}

define variable {
    any_of {
        IDENT           :"Without type. If the variable is not declared, it is automatically declared with var"
        ident_type      :"Identifier with type"
    }
}

define ident_type {
    types IDENT         :"Select type of identifier"
}

define types {
    any_of {
        var             :"The scope of a var variable is functional scope"
        let             :"The scope of a let variable is block scope"
        const           :"The scope of a const variable is block scope"
    }
}

define primary_expr {
    any_of {
        variable                : "An identifier starting with _ or a uppercase/lowercase letter following by 0 or more characters that can be _ numbers lowercase/uppercase letters"
        INT_CONST               : "An integer is a positive, zero, or negative number that can be written without a fractional component (i.e. no decimal point places)"
        FLOAT_CONST             : "A floating-point number is a rational number (i.e. includes numbers with decimal point places"
        CHAR_CONST              : "One single character"
        STRING_CONST            : "Any sequence of characters or the empty sequence"
        BOOLEAN                 : "One of true or false"
        ARRAY_CONST             : "An array of elements"
        OBJECT_CONST            : "Variable with many values as pairs (name:value)"
        func_def                : "Function definition as a value of an object"
    }
}

define BOOLEAN {
    any_of {
        true
        false
    }
}

define call_expr {
    any_of {
        input_output_call       : "Use a built-in input/output function"
        math_call               : "Use a built-in math function"
        string_method_call      : "Use a built-in string method"
        array_method_call       : "Use a built-in array method"
        object_method_call      : "Use a built-in object method"
        function_call           : "Use a user-defined function as \"name(params);\""
        object_function_call    : "Use a function which is member of an object as \"object.function()\""
    }
}

define ARRAY_CONST {
    "[" element_list "]"
}

define element_list {
    list_of expr(element)
}

define OBJECT_CONST {
    "{" pair_element_list "}"
}

define pair_element_list {
    list_of pair_element
}

define pair_element {
    IDENT           : "The identifier of the value"
    ":"             : "The pair"   
    expr(value)     : "The value of the property"
}

define assign_expr {
    IDENT                   :"Left operand to be assigned"
    assign_op               :"Assign operator, simple or with an operation "
    expr                    :"Right operand"
}

define assign_op {
    any_of{
        ASSIGN("=")                     :"Assigns the right operand to the left operand"            
        PLUS_ASSIGN("+=")               :"Sums up left and right operand values and assigns the result to the left operand"
        SUB_ASSIGN("-=")                :"Subtract right operand value from the left operand value and assigns the result to the left operand"
        MULT_ASSIGN("*=")               :"Multiply left and right operand values and assigns the result to the left operand"
        DIV_ASSIGN("/=")                :"Divide left operand value by right operand value and assign the result to the left operand"
        MOD_ASSIGN("%=")                :"Get the modulus of left operand divide by right operand and assign resulted modulus to the left operand"
        EXP_ASSIGN("**=")               :"Raises the value of left operand to the power of the right operand and assign the result to the left operand"
        LEFT_SHIFT_ASSIGN("<<=")        :"Moves the specified amount of bits(right operand) to the left and assigns the result to the left operand"
        RIGHT_SHIFT_ASSIGN(">>=")       :"Moves the specified amount of bits(right operand) to the right and assigns the result to the left operand"
        UN_RIGHT_SHIFT_ASSIGN(">>>=")   :"Unsigned -  moves the specified amount of bits to the right and assigns the result to the left operand"
    }
}

define func_def {
    function IDENT(Name) "(" ident_list ")" "{" stmts "}"
}

define break_stmt {
    break ";"
}

define continue_stmt {
    continue ";"
}

define return_stmt {
    return
    expr
    ";"
}

define function_call {
    IDENT("function name") "(" expr_list ")"
}

define array_method_call {
    IDENT(array) "." array_method "(" ")"
}

define object_method_call {
    IDENT("object name") "." object_method
}

define object_function_call {
    IDENT("object name") "." IDENT("function name") "(" expr_list ")"
}

define array_method {
    any_of { 
        array_get(get)                  : "Get an element by its position in the array"
        array_insert(insert)            : "Insert an element at a position in the array. Elements that previously were at the position, or after it, are moved one place to the right"
        array_push_back(push)           : "Insert an element at the end of the array"
        array_pop(pop)                  : "Returns the last element of the array"
        array_set(set)                  : "Modify an element in a position of the array to a new character"
        array_size(length)              : "Get the count of elements in the array"
        array_join(join)                : "The join method also joins all array elements into a string, you can specify the separator"
    }
}

define object_method {
    any_of { 
        object_get(get)                 : "Get an element by its property name in the object e.g objectName.property"
        object_delete(delete)           : "Delete a pair (property:value) by property name"
        object_set(set)                 : "Modify a value by its property name in the object to a new value. If the property does not exist,the pair property:value will be added in the object"
        object_size(length)             : "Get the count of properties in the object"
    }
}

define array_get {
    get WITH expr(index)
}

define array_insert {
    insert WITH expr(index) expr(element)
}

define array_push_back {
    push "(" expr(element) ")"
}

define array_pop {
    pop
}

define array_set {
    set WITH expr(index) expr(element)
}

define array_size {
    length
}

define object_get {
    getP WITH expr(property)
}

define object_delete {
    deleteP WITH expr(property)
}

define object_set {
    setP WITH expr(property)
}

define object_size {
    length
}

define string_method_call {
    "IN STRING" expr("string") CALL string_method
}

define string_method {
    any_of {
        string_append(append)                           : "Get a new string with the argument string added to the end (suffix) of the original"
        string_get_character(get_character)             : "Get the character at the specified position of the string"
        string_get_substring(get_substring)             : "Get a substring of a string, giving a start position and an end position"
        string_size(length)                             : "Get the count of characters contained in the string"
    }
}

define string_append {
    append WITH expr("string")
}

define string_get_character {
    get_character WITH expr(index)
}

define string_get_substring {
    get_substring WITH expr(start_index) expr(end_index)
}

define string_size {
    length
}

define input_output_call {
    any_of {
        input_output_print(print)       : "Print the value of the given expression (text, number etc.)"
        input_output_input(input)       : "Prompt the user with a text message and get user-input"
    }
}

define input_output_print {
    CALL print WITH expr_list
}

define input_output_input {
    CALL input WITH expr(prompt_message)
}

define math_call {
    any_of {
        math_pow(pow)                       : "Raise a number into a power"
        math_sqrt(sqrt)                     : "Get the square root of a number"
        math_round(round)                   : "Get the nearset integer to the given number"
        math_floor(floor)                   : "Get the greatest integer less than or equal to the given number"
        math_ceiling(ceiling)               : "Get the least integer greater than or equal to the given number"
        math_sin(sin)                       : "Get the sin of the given angle in degrees"
        math_cos(cos)                       : "Get the cos of the given angle in degrees"
    }
}

define math_pow {
    CALL pow WITH expr(number) expr(exponent)
}

define math_sqrt {
    CALL sqrt WITH expr(number)
}

define math_round {
    CALL round WITH expr(number)
}

define math_floor {
    CALL floor WITH expr(number)
}

define math_ceiling {
    CALL ceiling WITH expr(number)
}

define math_sin {
    CALL sin WITH expr(number)
}

define math_cos {
    CALL cos WITH expr(number)
}

define if_stmt {
    if "(" expr(condition_expr) ")" "{" stmts(if_part) "}"
}

define if_else_stmt {
    if "(" expr(condition_expr) ")" "{" stmts(if_part) "}" else "{" stmts(else_part) "}"
}

define while_stmt {
    while "(" expr(condition_expr) ")" "{" stmts(while_part) "}"
}

define for_stmt {
    for "("
    expr(initialization_expr) ";"
    expr(condition_expr) ";"
    expr(step_expr) ")"
    "{" stmts(for_part) "}"
}

define ident_list {
    list_of variable
}

define expr_list {
    list_of expr(arg)
}